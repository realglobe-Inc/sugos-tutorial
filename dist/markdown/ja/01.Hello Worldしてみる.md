# 【SUGOS】チュートリアル001: Hello Worldしてみる


このチュートリアルでは、SUGOSを使ったもっとも簡単な例を実装します。
Actor側で定義し、関数をCallerから呼び出すところまでをやります

## 事前準備

SUGOSは基本的にNode.js上で稼働します。 [nvm]()などを利用して、以下の環境を事前に用意してください。

+ [Node.js >=6.x](https://nodejs.org/en/)
+ [npm >=3.x]()

## 実装してみる

### プロジェクトの用意

まずはプロジェクトディレクトリを用意します。

```bash
mkdir sugos-tutorial-01
cd sugos-tutorial-01
npm init -y

```

次に、必要なパッケージをインストールします


```bash
npm install sugo-actor sugo-caller sugo-hub co asleep -S
```

### Hubサーバを立てる

命令を中継するための[SUGO-Hub](https://github.com/realglobe-Inc/sugo-hub)サーバを立てます。

以下のようなスクリプトを用意した後、

**hub.js**
```javascript
#!/usr/bin/env node

/**
 * Start hub server
 * @see https://github.com/realglobe-Inc/sugo-hub
 */
'use strict'

const sugoHub = require('sugo-hub')

const co = require('co')

co(function * () {
  let hub = yield sugoHub({
    // Options
    port: 3000
  })
  console.log(`SUGO Cloud started at port: ${hub.port}`)
}).catch((err) => {
  console.error(err)
  process.exit(1)
})

```

Nodeで実行します。

```bash
node ./hub.js
```

パフォーマンス的な理由からRedisを使うべきだという警告がでますが、ここでは無視で構いません。


### Moduleを宣言する

次にActorにつなぐためのModuleを宣言します。
ここではPingを打つとPongを返すだけの簡単間のを用意します。

**modules/table-tennis.js**
```javascript

```

モジュールで宣言したメソッドは後でActorを通じてCaller側に公開されます。

なお、メソッドの戻り値に[Promise](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promiseオブジェクトを渡すことで非同期に処理を扱えるようになります。
ここではより直感的な記述的にするために、[co](https://github.com/tj/co#readme)パッケージを利用しています。


### ActorにModuleを載せてHubにつなぐ

Moduleが用意できたら、それを[SUGO-Actor](https://github.com/realglobe-Inc/sugo-actorに載せます。

接続先となるhubのhost名と、自身の識別子となる`key`項目、使うモジュールを渡してactorインスタンスを生成します。

**actor.js**
```javascript
#!/usr/bin/env node

/**
 * Connect actor
 */
'use strict'

const sugoActor = require('sugo-actor')
const co = require('co')
const tableTennis = require('./modules/table-tennis')

co(function * () {
  let actor = sugoActor({
    host: 'localhost:3000',
    key: 'my-actor-01',
    /** Modules to load */
    modules: {
      tableTennis
    }
  })

// Connect to hub
  yield actor.connect()

  console.log(`Actor connected to: ${actor.socket.io.uri}`)
}).catch((err) => console.error(err))

```

Actorのスクリプトが用意できたらそれを実行してhubにつなぎます。

```bash
node ./actor.js
```


### Callerから呼び出す

Callerからは`.connect()`メッソドに、keyを指定することで特定のActorに接続することができます。
先ほど宣言した"my-actor-01"をkeyとて渡し、そこから'tableTennis'にアクセスします。

**caller.js**
```javascript
/**
 * Use sugo caller
 * @see https://github.com/realglobe-Inc/sugo-caller#readme
 */
'use strict'

const co = require('co')
const sugoCaller = require('sugo-caller')

co(function * () {
  let caller = sugoCaller({
    host: 'localhost:3000'
  })

  // Connect to actor
  let myActor01 = yield caller.connect('my-actor-01')
  let tableTennis = myActor01.get('tableTennis')

  let pong = yield tableTennis.ping()
  console.log(`Pong from myActor01/tableTennis: "${pong}"`)

}).catch((err) => console.error(err))

```

このスクリプトを実行し、無事pongが帰ってきたら成功です。


## おまけ

今回できたスクリプトを含め、SUGOSチームではコーディング規約として[standard JS](https://github.com/feross/standard#------javascript-standard-style--)を採用しています。
これはソースコードの中でインテンドをいくつにするか、セミコロンをどうすると行ったルールを規程し、チェックするものです。

以前はチーム内のメンバが異なるエディタを使っているため、フォーマッタによって毎度Gitの差分が出てしまうという問題が生じていました。
standard JSでは

+ ルールが徹底している
+ 個別の設定がいらない
+ 様々なエディタに対応している

という利点があり、現在ではチーム標準となりました。同じような差分に悩んでいる方がいたら導入してみると良いかもしれません。


## リンク

+ [SUGOS](https://github.com/realglobe-Inc/sugos)
+ [SUGO-Hub](https://github.com/realglobe-Inc/sugo-hub)
+ [SUGO-Actor](https://github.com/realglobe-Inc/sugo-actor)
+ [SUGO-Caller](https://github.com/realglobe-Inc/sugo-caller)